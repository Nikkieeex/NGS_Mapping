---
title: "Logboek_samen"
output: html_document
---

## 29-9-2025

Vandaag gaan we bezig met week 3 van de les stof en de eerste opdracht hierin is dat we de BED-data gaan lezen.


*Opdracht 1:*

```{r}
BED_file <-read.table("/commons/Themas/Thema05/2025/CardioPanel/CAR_0394321__en-20_target_v2_hg38.bed")
head(BED_file)
```

Omdat de columns geen namen hebben word dit autotmatisch v1 v2, dit moeten we veranderen:

```{r}
names(BED_file)<- c("chromosome", "begin", "end","gene")
head(BED_file)
```

## 30-9-2025 
Vandaag ga ik verder met wat ik gisteren gestart was, ik volg gewoon de stappen van week 3 nog.

Het printen van de exons nummers per chromosoom, in elke rij zit 1 exon dus ik moet eigenlijk gewoon de hele tabel printen?

```{r}
exons <- table(BED_file$chromosome)
exons
```

Hier is te zien hoeveel exonen er per chromosoom zijn deze kan je plotten:

```{r}
barplot(exons,
        ylab = "Exonen nummers",
        las = 2)
```

*opdracht 2:*

Het visualiseren van de nummers van genen per chromosoom, hiervoor moeten we een subset creeeren met elke unieke chromosoom-genen combinatie. Hiervoor kunnen we de table functie weer gebruiken.
```{r}
# selecteren van de chromosoom en gene columns
chrom_gene <- BED_file[, c("chromosome", "gene")]

# het verwijderen van duplicates 
unique_genes <- unique(chrom_gene)

# tellen van genen per chromosoom
gene_counts <- table(unique_genes$chromosome)

# Plotten van het resultaat
barplot(gene_counts,
        ylab = "Aantal unieke genen per chromosoom",
        las = 2)  # Draait de x-as labels verticaal voor betere leesbaarheid
```

_opdracht 3:_

libraries wat we gaan gebruiken:
```{r}
## Only needed when the package is missing
if (!require("BiocManager"))
    install.packages("BiocManager")

BiocManager::install("GenomicRanges")
```
```{r}
# This package contains the 'IRanges', 'GRanges' and 'GRangesList' classes we will use
library(GenomicRanges)
```

```{r}
# print alle rijen waar alle genomen SOD2 zijn
sod2 <- BED_file[BED_file$gene == "SOD2", ]
```

```{r}
# wijs de hele kolom toe aan IRanges argumenten
ranges <- IRanges(start = sod2$begin,
                  end = sod2$end,
                  names = sod2$gene)
ranges
```
IRanges word gebruikt om een soort van lijst te maken zodat R precies weet waar elk stukje begint, eindigt en hoe die heet. Dit is makkelijk om makkelijk te zien of er stukjes overlappen, of om te zoeken naar bepaalde regios. 

```{r}
# het berekenen van de lengte van een gene
cat("Lengte van SOD2:", sum( width( ranges) ), "bp")
```

Hier zie je eigenlijk hetzelfde als dat met de IRanges maar er missen enkele gegevens, daarom gaan we het IRanges omzetten naar GRanges, dit doen we om eigenlijk extra biologische data toe te voegen.
```{r}
granges <- GRanges(seqnames = sod2$chromosome,
                   ranges = ranges)
granges
```
Wat kunnen we nu eigenlijk met de granges? Met alleen de BED-data niet zo heel veel, maar we gaan de Pileup data ook in een vergelijkbare GRanges object plaatsen, hiermee kunnen we met onze data interessante vragen stellen met de pileup functie. Bijvoorbeeld specifiek iets vragen over exonen en de rest negeren. 

Voor dat we dat kunnen doen moeten we eerst de BED-data in het goede formaat zetten. 

De eerste stap hierbij een lege lijst creeeren:
```{r}
my_list <- list()
```

De tweede stap is om te itereren over alle genen in het BED-bestand:
```{r}
# split het BED-bestand op gene
gene_group <- split(BED_file, BED_file$gene)

# Itereer over elke gene
for (gene_name in names(gene_group)) {
  gene_data <- gene_group[[gene_name]]
  # Maak een GRanges object
  gr <- GRanges(seqnames = gene_data$chromosome,
                ranges = IRanges(start = gene_data$begin, end = gene_data$end),
                gene = gene_name)
  
  # Voeg toe aan de lijst
  my_list[[gene_name]] <- gr
}

# Zet de lijst om naar een GRangesList
my_list <- GRangesList(my_list)

my_list
```
```{r}
my_list["SOD2"]
```

dit werkt dus mooi:D.

_opdracht 4_
In deze opdracht moeten we nog een visualisatie maken gebaseerd op de BED-data maar nu gebruiken we de GRange object.

```{r}
psen2_ranges <- ranges(BED_file[['PSEN2']])
paste("Length of the 'PSEN2' gene:", sum(width(psen2_ranges)), "\n")
```
Hier kom ik ff niet verder en ga hier morgen denk ik verder aan werken.

## 01-10-2025


Vandaag ga ik verder met **opdracht 4 t/m 7**


_opdracht 4_ 

Genlengten (exonen) en visualisatie

Per gen de totale lengte in bp (som van exonlengten) berekenen en een overzichtsplot maken

```{r}
# Lengte van een specifiek gen (voorbeeld PSEN2) en som van exonbreedtes
psen2_ranges <- ranges(my_list[["PSEN2"]])
paste("Lengte van 'PSEN2' (exonen):", sum(width(psen2_ranges)), "bp")

# Alle genlengten (som van exonen per gen)
gene_lengths <- sapply(my_list, function(gr) sum(width(gr)))
gene_lengths <- sort(gene_lengths, decreasing = TRUE)

# Basale barplot, lange genen kunnen de schaal domineren
barplot(gene_lengths,
        las = 2,
        ylab = "Genlengte (som exonen, bp)",
        main = "Exon-gebaseerde genlengten (panel)")
```

Je ziet dat sommige genen veel langer zijn, waardoor de rest moeilijk te vergelijken is. Als TTN er niet tussen stond kon je beter verschillen zien. 


_opdracht 5_ 

BAM-bestand laden en pileup voor één gen en Rsamtools gebruiken
En bam en bai files nog op logische plek zetten

```{r}
if (!requireNamespace("Rsamtools", quietly = TRUE)) BiocManager::install("Rsamtools")
library(Rsamtools)

# JOHANNA PAS DIT PAD NOG AAN
bam_path <- "C:/Users/nicol/Documents/NGS_en_Genetics/MarkDuplicates on collection 28_BAM/bestand.bam"
bai_path <- "C:/Users/nicol/Documents/NGS_en_Genetics/MarkDuplicates on collection 28_BAM/bestand.bam.bai"

# Controle
bam_file <- BamFile(bam_path, index = bai_path)

# Test op 1 gen voorbeeld SOD2
test_gene <- "SOD2"
test_ranges <- my_list[[test_gene]]

# Pileup zonder onderscheid naar strand naar totale dekking per base
pu_params <- PileupParam(distinguish_nucleotides = FALSE,
                         distinguish_strands    = FALSE)

test_pileup <- pileup(file = bam_file,
                      scanBamParam = ScanBamParam(which = test_ranges),
                      pileupParam  = pu_params)

head(test_pileup)
```
beschrijf dit nog evne


_opdracht 6_

Pileup verwerken voor alle genen en in een lijst opslaan voor latere aggregatie

```{r}
coverage_list <- list()

for (g in names(my_list)) {
  gr <- my_list[[g]]
  pu <- pileup(file = bam_file,
               scanBamParam = ScanBamParam(which = gr),
               pileupParam  = pu_params)
  if (nrow(pu) > 0) {
    pu$gene <- g
  } else {
    # lege df met juiste kolommen
    pu <- data.frame(seqnames = character(),
                     pos      = integer(),
                     count    = integer(),
                     gene     = character())
  }
  coverage_list[[g]] <- pu
}

# Snelle sanity-check op een gen dat zeker in de panel zit
head(coverage_list[[test_gene]])
```

coverage_list bevat nu per gen een data.frame met minimaal kolommen pos, count, gene. Lege data.frames duiden op 0 reads in de targetregio.


_opdracht 7_

Coverage berekenen en rapporteren

per gen rapporteren:
aantal basen
gemiddelde dekking
aantal posities met lange dekking en percentage


```{r}
options(stringsAsFactors = FALSE)

gene_metrics <- data.frame(
  gene            = names(my_list),
  length_bp       = as.integer(sapply(my_list, function(gr) sum(width(gr)))),
  total_coverage  = numeric(length(my_list)),
  avg_coverage    = numeric(length(my_list)),
  low_cover_bases = integer(length(my_list)),
  low_cover_pct   = numeric(length(my_list))
)

for (g in names(my_list)) {
  gene_len <- sum(width(my_list[[g]]))
  df <- coverage_list[[g]]

  if (nrow(df) > 0) {
    # df$count is totale dekking per base (strand/nucleotide al samengenomen)
    total_cov <- sum(df$count)
    high_cov_positions <- sum(df$count >= 30)
  } else {
    total_cov <- 0
    high_cov_positions <- 0
  }

  low_cov_positions <- gene_len - high_cov_positions
  avg_cov <- if (gene_len > 0) total_cov / gene_len else 0

  gene_metrics[gene_metrics$gene == g, "total_coverage"]  <- total_cov
  gene_metrics[gene_metrics$gene == g, "avg_coverage"]    <- avg_cov
  gene_metrics[gene_metrics$gene == g, "low_cover_bases"] <- low_cov_positions
  gene_metrics[gene_metrics$gene == g, "low_cover_pct"]   <- (low_cov_positions / gene_len) * 100
}

# Sorteren op % lage dekking aflopend
gene_metrics <- gene_metrics[order(-gene_metrics$low_cover_pct, gene_metrics$gene), ]

```



